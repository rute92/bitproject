A* 알고리즘

1. 탐색 영역 둘러보기
시작지점(A) 및 목표지점(B) 설정. 그리고 탐색 지역을 네모난 grid 로 나누어 단순화시킴.
각 사각형을 노드라고 칭함.

2. 탐색 시작
A점부터 B까지 인접 사각형을 확인하며 길을 만들어나감.
  a. 시작점 A를 '열린 목록'에 넣음. 일종의 장바구니
  b. 시작점에 인접한 이동 불가능한 노드는 무시하고 이동 가능한 노드를 '열린 목록'에 넣어줌.
      이 노드들의 부모를 시작점 A로 지정.
  c. '열린 목록'에서 시작점 A 노드를 삭제하고 다시 볼 필요 없는 '닫힌 목록'에 추가
  d. '열린 목록'에 있는 노드 중 가장 작은 비용(F)를 가진 하나를 선택해 위 순서로 반복 처리.

3. 경로 채점
비용(F) 채점하기
F = G + H
- G : 시작점 A로부터 현재 노드까지의 경로를 따라 이동하는데 소요되는 비용
- H : 현재 노드에서 목적지 B까지의 예상 이동 비용. 이동 불가능한 노드는 무시하고 단순 거리로.
       (대각선 이동을 생각하는지 아닌지에 따라 다름. 여기선 대각선 x)
- F : 현재까지 이동하는데 걸린 비용과 예상 비용을 합친 총 비용(F)

G 비용
예를들어 수직/수평 이동에 대해선 비용이 10, 대각선 이동은 14의 비용을 할당.
현재 노드의 G 비용 계산은 부모노드의 G 비용 + 부모노드로부터 현재 노드의 비용.

H(휴리스틱스) 비용
다양한 방식으로 추정 가능하며 예로 맨하탄(Manhattan) 방법이 있음. 
맨하탄 방법 - 현재 노드에서 대상 노드에 도달하기 위해 대각선 운동과 장애물은 무시하고
  수평/수직 이동 비용만 계산.

F 비용
최종적으로 G 비용과 H 비용을 더하여 어떤 경로가 가장 비용이 싼지 채점.

4. 계속 탐색하기
'열린 목록'에서 가장 작은 F비용을 가지고 있는 노드를 선택하고 아래와 같이 진행
  a. 선택한 노드를 '열린 목록'에서 빼고 '닫힌 목록'에 넣어줌.
  b. 인접한 노드를 확인. '닫힌 목록'에 있거나 벽은 무시하고 '열린 목록'에 없는 노드가 있다면 추가.
  c. 인접한 노드가 이미 '열린 목록'에 있다면 해당 노드의 비용이 더 좋은지 확인.
     즉, 선택한 노드와 비교해 G 점수가 어떤 것이 더 낮은지 확인하여 해당 노드가 더 낮다면
     인접 노드의 부모를 새로운 노드로 바꿈. 마지막으로 다시 그 노드의 F와 G를 다시 계산.


전체 과정 요약
1. 시작 노드에서 검색된 인접 노드들을 열린 목록에 넣음.
2. 다음의 과정 반복 
  a. 열린 목록에서 가장 낮은 F 비용을 찾아 현재 노드로 선택.
  b. 이것을 열린목록에서 꺼내 닫힌목록으로 넣음.
  c. 선택한 노드에 인접한 8개의 노드에 대해 탐색
    - 만약 인접한 노드가 갈 수 없는 벽이거나 닫힌목록에 있으면 무시, 그렇지 않은것은 다음을 계속
    - 만약 열린목록에 있지 않다면 열린 목록에 추가하고 이 노드의 부모를 현재 노드로 만듦.
      사각형의 F, G, H 비용을 기록
    - 만약 이미 열린목록에 있다면 G 비용을 이용해 이 노드가 더 나은지 알아보고 그것의 G비용이 더
      작다면 부모 노드를 그 노드(G 비용이 더 작은)로 바꿈, 그리고 그 노드의 G, F 비용을 다시 계산
  d. 그만해야 할 때
    - 길을 찾는 중 목표 노드를 열린 목록에 추가했을 때.
    - 열린 목록이 비어있게 될 때. (이 경우는 길이 없는 경우임)
3. 길 저장하기
  - 목표 노드로부터 각 노드의 부모노드를 향해 시작 노드에 도착할 때 까지 거슬러 올라감.

